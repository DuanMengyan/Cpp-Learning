#pragma once
#pragma execution_character_set("utf-8")


/*************************************************************************
> File Name: Chapter13.2.cpp
> Author: DMY
> Mail: dmy_email@163.com
> Created Time: 2019年2月23日 星期六
> Last edited time: 2019年2月24日 星期日
> Topic:C++Primer Chapter13.2 拷贝控制和资源管理
************************************************************************/

#include "header_include.h"
#include "Sales_data.h"
#include "StrBlob.h"
#include "StrBlobPtr.h"
#include "HasPtr.h"

using namespace std;


//Chapter13.2.1 行为像值的类
void Fun_Classes_That_Act_Like_Values()
{
	//为了实现类值行为，HasPtr需要：
	//1.定义一个拷贝构造函数，完成string的拷贝，而不是拷贝指针
	//2.定义一个析构函数来释放string
	//3.定义一个拷贝赋值运算符来释放对象当前的string，并从右侧运算对象拷贝string

	//类值拷贝赋值运算符，在销毁左侧运算对象资源之前，拷贝右侧运算对象
	//1.如果将一个对象赋予它自身，赋值运算符必须能够正确工作
	//2.大多数赋值运算符组合了析构函数和拷贝构造函数的工作
	//先将右侧运算对象拷贝到一个局部临时对象中，拷贝完成后，销毁左侧运算对象的现有成员就是安全的了。
	//一旦左侧运算对象的资源被销毁，就只剩下将数据从临时对象拷贝到左侧运算对象的成员中了

	//ex13.23
	//拷贝赋值运算符函数编写，在销毁左侧运算对象资源之前，拷贝右侧运算对象
	
	//ex13.24
	//如果没有定义析构函数，则会造成内存泄漏，合成版本析构函数不管理动态内存
	//如果没有定义拷贝构造函数，对于ps的拷贝就会是指针本身的拷贝（违反类值行为规则第一条）

	//ex13.25
	//StrBlob成员是智能指针，可以使用合成析构函数管理动态内存
	//拷贝构造函数和拷贝赋值运算符函数应为自己动态分配内存，而不是和右侧运算对象共享

	//ex13.26
	
}

int main()
{
	
	return 0;
}
